<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice AI Assistant (WebRTC)</title>
    <style>
        /* CSS Styles */
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #f4f7f6;
            color: #333;
        }
        .container {
            width: 100%;
            max-width: 600px;
            background: #fff;
            padding: 25px; 
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        h1 {
            color: #007bff;
            margin-bottom: 20px;
            text-align: center;
        }
        button {
            padding: 12px 25px;
            font-size: 16px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.1s;
            margin: 5px;
            flex: 1;
        }
        #start-button {
            background-color: #28a745;
            color: white;
        }
        #start-button:hover:not(:disabled) {
            background-color: #218838;
            transform: scale(1.02);
        }
        #stop-button {
            background-color: #dc3545;
            color: white;
        }
        #stop-button:hover:not(:disabled) {
            background-color: #c82333;
            transform: scale(1.02);
        }
        button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
            color: #ccc;
        }
        #chat-log {
            height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 15px;
            margin-top: 20px;
            border-radius: 8px;
            background-color: #e9ecef;
        }
        .message {
            margin-bottom: 10px;
            padding: 8px 12px;
            border-radius: 6px;
        }
        .user-msg {
            text-align: right;
            background-color: #d1e7dd;
            margin-left: 20%;
        }
        .bot-msg {
            text-align: left;
            background-color: #f8d7da;
            margin-right: 20%;
        }
        #status {
            margin-top: 10px;
            font-weight: bold;
            color: #007bff;
        }
        .api-config input {
             box-sizing: border-box; 
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>üó£Ô∏è Voice AI Assistant</h1>

        <div class="api-config" style="margin-bottom: 20px;">
            <label for="apiKeyInput" style="display: block; margin-bottom: 5px; font-weight: bold;">API Key (Gemini/LLM):</label>
            <input type="text" id="apiKeyInput" placeholder="Nh·∫≠p API Key (MOCK n·∫øu ƒë·ªÉ tr·ªëng)" style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 6px;">
        </div>
        
        <div id="controls">
            <button id="start-button">B·∫Øt ƒê·∫ßu Ghi √Çm</button>
            <button id="stop-button" disabled>D·ª´ng Ghi √Çm</button>
        </div>

        <p id="status">Tr·∫°ng th√°i: S·∫µn s√†ng</p>

        <audio id="remote-audio" autoplay style="display: none;"></audio>
        
        <div id="chat-log">
            <div class="message bot-msg"><strong>Bot:</strong> Ch√†o b·∫°n, t√¥i c√≥ th·ªÉ gi√∫p g√¨ cho b·∫°n? (ƒêang ch·ªù k·∫øt n·ªëi...)</div>
        </div>
    </div>

    <script>
        const START_BUTTON = document.getElementById('start-button');
        const STOP_BUTTON = document.getElementById('stop-button');
        const STATUS_ELEM = document.getElementById('status');
        const CHAT_LOG = document.getElementById('chat-log');
        const REMOTE_AUDIO = document.getElementById('remote-audio');
        const API_KEY_INPUT = document.getElementById('apiKeyInput'); 
        const SERVER_URL = ""; // ƒê·ªÉ tr·ªëng ho·∫∑c d√πng http://127.0.0.1:8000
        
        let pc = null; 
        let localStream = null; 
        let dataChannel = null;

        // ==================== UI LOGIC ====================

        function setStatus(message, isError = false) {
            STATUS_ELEM.textContent = `Tr·∫°ng th√°i: ${message}`;
            STATUS_ELEM.style.color = isError ? '#dc3545' : '#007bff';
        }

        function addMessageToLog(sender, text) {
            const msgDiv = document.createElement('div');
            msgDiv.className = `message ${sender}-msg`;
            msgDiv.innerHTML = `<strong>${sender === 'user' ? 'B·∫°n' : 'Bot'}:</strong> ${text}`;
            CHAT_LOG.appendChild(msgDiv);
            CHAT_LOG.scrollTop = CHAT_LOG.scrollHeight;
        }
        
        // ==================== WEBRTC LOGIC ====================

        async function startRecording() {
            if (pc) {
                await closeConnection(false);
            }

            setStatus("ƒêang k·∫øt n·ªëi t·ªõi AI...");
            START_BUTTON.disabled = true;

            try {
                // 1. L·∫•y Stream t·ª´ Microphone (Input) - B∆Ø·ªöC KH·∫ÆC PH·ª§C L·ªñI "KO C√ì LOG"
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                console.log("‚úÖ ƒê√£ l·∫•y ƒë∆∞·ª£c Micro phone stream.");
                
                setStatus("üé§ ƒêang nghe... (Click D·ª´ng ƒë·ªÉ g·ª≠i)");

                // 2. Kh·ªüi t·∫°o RTCPeerConnection
                pc = new RTCPeerConnection();

                // X·ª≠ l√Ω s·ª± ki·ªán thay ƒë·ªïi tr·∫°ng th√°i k·∫øt n·ªëi
                pc.onconnectionstatechange = (event) => {
                    console.log(`Connection state change: ${pc.connectionState}`);
                    if (pc.connectionState === 'failed') {
                        setStatus("K·∫øt n·ªëi WebRTC th·∫•t b·∫°i.", true);
                        closeConnection(false);
                    } 
                    if (pc.connectionState === 'connected') {
                        // K√≠ch ho·∫°t n√∫t Stop khi k·∫øt n·ªëi th√†nh c√¥ng (nh∆∞ng v·∫´n c√≥ th·ªÉ k√≠ch ho·∫°t s·ªõm h∆°n)
                        STOP_BUTTON.disabled = false;
                    }
                };

                // X·ª≠ l√Ω lu·ªìng Audio TTS t·ª´ Backend
                pc.ontrack = (event) => {
                    if (event.track.kind === 'audio') {
                        console.log("üîä Nh·∫≠n ƒë∆∞·ª£c Audio Track TTS t·ª´ Bot.");
                        
                        setStatus("üîä ƒêang ph√°t ph·∫£n h·ªìi...");

                        // LOGIC ƒê√ìNG K·∫æT N·ªêI AN TO√ÄN SAU KHI TTS CH·∫†Y XONG
                        event.track.onended = () => {
                            console.log("‚úÖ Lu·ªìng TTS t·ª´ Bot ƒë√£ k·∫øt th√∫c! Ti·∫øn h√†nh ƒë√≥ng k·∫øt n·ªëi an to√†n.");
                            setTimeout(() => {
                                closeConnection(true); 
                            }, 100); 
                        };

                        // 3. G√°n Stream Audio TTS (remoteStream) cho th·∫ª <audio> ƒë·ªÉ ph√°t
                        const remoteStream = event.streams[0];
                        REMOTE_AUDIO.srcObject = remoteStream;
                        REMOTE_AUDIO.play().catch(e => console.error("L·ªói ph√°t audio:", e));
                    }
                };

                // 4. Th√™m track microphone v√†o PeerConnection
                localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
                STOP_BUTTON.disabled = false; 

                // 5. T·∫°o Offer SDP
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);

                // 6. G·ª≠i Offer ƒë·∫øn Server Backend (Bao g·ªìm API Key)
                const apiKey = API_KEY_INPUT.value.trim(); 
                
                console.log("‚û°Ô∏è G·ª≠i Offer SDP t·ªõi Backend...");
                const response = await fetch(`${SERVER_URL}/offer`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sdp: pc.localDescription.sdp,
                        type: pc.localDescription.type,
                        api_key: apiKey, 
                    }),
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Server returned status: ${response.status}. Chi ti·∫øt: ${errorText}`);
                }

                const answer = await response.json();
                console.log("‚¨ÖÔ∏è Nh·∫≠n Answer SDP t·ª´ Backend.");

                // 7. Thi·∫øt l·∫≠p Answer SDP t·ª´ Server
                await pc.setRemoteDescription(new RTCSessionDescription(answer));
                
                // 8. Ch·ªù Data Channel ƒë·ªÉ nh·∫≠n Metadata (Text)
                pc.ondatachannel = (event) => {
                    dataChannel = event.channel;
                    dataChannel.onmessage = (e) => {
                        try {
                            const data = JSON.parse(e.data);
                            addMessageToLog('user', data.user_text || '...');
                            addMessageToLog('bot', data.bot_text || '...');
                        } catch (err) {
                            console.error("L·ªói x·ª≠ l√Ω Data Channel Message:", err);
                        }
                    };
                };

            } catch (error) {
                console.error("‚ùå L·ªói kh·ªüi t·∫°o WebRTC:", error);
                
                // X·ª¨ L√ù L·ªñI MICROPHONE PH·ªî BI·∫æN
                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    setStatus("L·ªñI MICROPHONE: B·∫°n ph·∫£i **cho ph√©p** tr√¨nh duy·ªát truy c·∫≠p Microphone.", true);
                } else if (error.message.includes("Server returned status")) {
                    setStatus(`L·ªñI SERVER: ${error.message}. Ki·ªÉm tra Terminal Backend.`, true);
                } else {
                    setStatus(`L·ªói kh√¥ng x√°c ƒë·ªãnh: ${error.message}`, true);
                }
                
                closeConnection(false); 
            }
        }

        async function closeConnection(isSafeClose = false) {
            
            // 1. T·∫Øt Microphone
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            
            // 2. D·ª´ng ph√°t audio
            if (REMOTE_AUDIO.srcObject) {
                 REMOTE_AUDIO.pause();
                 REMOTE_AUDIO.srcObject = null;
            }

            // 3. ƒê√≥ng RTCPeerConnection
            if (pc && pc.connectionState !== 'closed' && pc.connectionState !== 'disconnected') {
                try {
                    await pc.close();
                } catch (e) {
                    console.error("L·ªói khi ƒë√≥ng PC:", e);
                }
            }
            pc = null;
            dataChannel = null;
            
            // 4. C·∫≠p nh·∫≠t UI
            START_BUTTON.disabled = false;
            STOP_BUTTON.disabled = true;
            if (isSafeClose) {
                setStatus("Ph·∫£n h·ªìi ho√†n t·∫•t. S·∫µn s√†ng.", false);
            } else {
                 if (!STATUS_ELEM.textContent.includes("L·ªñI")) {
                    setStatus("ƒê√£ d·ª´ng. S·∫µn s√†ng.", false);
                 }
            }
        }
        
        // ==================== EVENT LISTENERS V√Ä LOCAL STORAGE ====================

        START_BUTTON.addEventListener('click', startRecording);
        STOP_BUTTON.addEventListener('click', closeConnection);
        
        // Kh√¥i ph·ª•c/L∆∞u API Key t·ª´ Local Storage
        window.onload = function() {
            const savedKey = localStorage.getItem('voice_ai_api_key');
            if (savedKey) {
                API_KEY_INPUT.value = savedKey;
            } 
            setStatus("S·∫µn s√†ng.", false);
        };

        API_KEY_INPUT.addEventListener('change', () => {
            const key = API_KEY_INPUT.value.trim();
            localStorage.setItem('voice_ai_api_key', key);
            setStatus("API Key ƒë√£ ƒë∆∞·ª£c l∆∞u t·∫°m th·ªùi.", false);
        });
        
        window.addEventListener('beforeunload', closeConnection); 

    </script>
</body>
</html>