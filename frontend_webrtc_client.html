<!DOCTYPE html>
<html>
<head>
    <title>Voice AI Assistant (WebRTC)</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f4f4f9; }
        .container { max-width: 800px; margin: auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        h1 { color: #333; text-align: center; }
        .control-panel { display: flex; justify-content: space-around; margin-top: 20px; }
        button { padding: 10px 20px; font-size: 16px; cursor: pointer; border: none; border-radius: 5px; transition: background-color 0.3s; }
        #startBtn { background-color: #28a745; color: white; }
        #startBtn:hover { background-color: #218838; }
        #stopBtn, #cancelBtn { background-color: #dc3545; color: white; }
        #stopBtn:hover, #cancelBtn:hover { background-color: #c82333; }
        #cancelBtn { display: none; }
        .result-panel { margin-top: 20px; padding: 15px; border: 1px solid #ccc; border-radius: 5px; background-color: #fff; }
        #log-area, #asrResult, #botResponse { white-space: pre-wrap; word-wrap: break-word; min-height: 20px; padding: 5px; border-bottom: 1px solid #eee; }
        #log-area { max-height: 250px; overflow-y: scroll; font-size: 0.85em; background-color: #f9f9f9; }
        .log-status { color: #007bff; }
        .log-error { color: #dc3545; font-weight: bold; }
        .log-warn { color: #ffc107; }
        .status-bar { height: 10px; background-color: #e9ecef; border-radius: 5px; margin-top: 10px; overflow: hidden; }
        .status-progress { height: 100%; width: 0%; background-color: #007bff; transition: width 0.5s; }
        .api-key-config { margin-top: 20px; padding: 10px; background-color: #e9ecef; border-radius: 5px; }
        .api-key-config label { font-weight: bold; display: block; margin-bottom: 5px; }
        .api-key-config input { width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 3px; box-sizing: border-box; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Voice AI Assistant (WebRTC)</h1>

        <div class="api-key-config">
            <label for="apiKeyInput">API Key (T√πy ch·ªçn):</label>
            <input type="text" id="apiKeyInput" placeholder="Nh·∫≠p API Key n·∫øu c·∫ßn">
        </div>

        <div class="control-panel">
            <button id="startBtn" disabled>‚ñ∂Ô∏è B·∫Øt ƒê·∫ßu Ghi √Çm</button>
            <button id="stopBtn" disabled>‚èπÔ∏è D·ª´ng & X·ª≠ L√Ω</button>
            <button id="cancelBtn" disabled>‚ùå H·ªßy X·ª≠ L√Ω</button>
        </div>

        <div class="status-bar">
            <div id="statusProgress" class="status-progress"></div>
        </div>

        <div class="result-panel">
            <h2>K·∫øt Qu·∫£ X·ª≠ L√Ω</h2>
            <p><strong>ASR (Ng∆∞·ªùi D√πng):</strong> <span id="asrResult">...</span></p>
            <p><strong>Ph·∫£n H·ªìi (Bot):</strong> <span id="botResponse">...</span></p>
            <audio id="ttsAudio" controls autoplay></audio>
        </div>

        <div class="result-panel">
            <h2>Log H·ªá Th·ªëng</h2>
            <div id="log-area"></div>
        </div>
    </div>

    <script>
        // ======================================================
        // C√ÅC BI·∫æN TO√ÄN C·ª§C
        // ======================================================
        let pc; 
        let localStream;
        let dataChannel;
        let isProcessing = false;
        let sessionID = '';
        
        const WS_URL = "ws://localhost:8000/ws"; 
        let ws;

        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const cancelBtn = document.getElementById('cancelBtn');
        const logArea = document.getElementById('log-area');
        const ttsAudio = document.getElementById('ttsAudio');
        const asrResult = document.getElementById('asrResult');
        const botResponse = document.getElementById('botResponse');
        const statusProgress = document.getElementById('statusProgress');
        const apiKeyInput = document.getElementById('apiKeyInput');

        // ======================================================
        // C√ÅC H√ÄM TR·ª¢ GI√öP
        // ======================================================

        function log(message, type = 'log') {
            const time = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.innerHTML = `[${time}] ${message}`;
            logEntry.className = `log-${type}`;
            logArea.prepend(logEntry); 
        }

        function updateStatus(message, percent = 0) {
            log(message, 'status');
            statusProgress.style.width = `${percent}%`;
        }

        function resetUI() {
            startBtn.disabled = false;
            stopBtn.disabled = true;
            cancelBtn.style.display = 'none';
            asrResult.textContent = '...';
            botResponse.textContent = '...';
            statusProgress.style.width = '0%';
            ttsAudio.removeAttribute('src');
            isProcessing = false;
        }
        
        // ======================================================
        // L√îGIC KH·ªûI T·∫†O WEBSOCKET
        // ======================================================
        function initWebSocket() {
            // FIX: ƒê√≥ng k·∫øt n·ªëi WS c≈© n·∫øu c√≥
            if (ws && ws.readyState !== WebSocket.CLOSED) {
                ws.close();
            }
            
            // K·∫øt n·ªëi WS m·ªõi, s·ª≠ d·ª•ng sessionID m·ªõi
            ws = new WebSocket(`${WS_URL}?session_id=${sessionID}`);
            
            ws.onopen = () => {
                log("WebSocket ƒë√£ k·∫øt n·ªëi th√†nh c√¥ng.", 'status');
            };

            ws.onerror = (error) => {
                log(`L·ªói WebSocket: ${error.message || error}`, 'error');
            };

            ws.onclose = (event) => {
                log(`WebSocket ƒë√£ ƒë√≥ng. Code: ${event.code}.`, 'error');
            };
            
            ws.onmessage = async (event) => {
                try {
                    const message = JSON.parse(event.data);
                    if (message.type === 'candidate') {
                        // Th√™m ICE Candidate ch·ªâ khi pc ƒë√£ ƒë∆∞·ª£c t·∫°o
                        if (pc) {
                            await pc.addIceCandidate(new RTCIceCandidate(message.candidate));
                        }
                    }
                } catch (e) {
                    // B·ªè qua n·∫øu kh√¥ng ph·∫£i JSON
                }
            };
        }
        
        // ======================================================
        // L√îGIC X·ª¨ L√ù MEDIA (WEBRTC)
        // ======================================================

        function createPeerConnection() {
            resetUI();
            sessionID = crypto.randomUUID();
            updateStatus('B·∫Øt ƒë·∫ßu thi·∫øt l·∫≠p WebRTC...', 10);
            
            // ‚úÖ FIX L·ªñI ROUTING: Kh·ªüi t·∫°o WebSocket ngay b√¢y gi·ªù
            initWebSocket();

            const configuration = {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:global.stun.twilio.com:3478' }
                ]
            };

            try {
                pc = new RTCPeerConnection(configuration);
                
                // === HANDLERS CHO PC ===
                
                pc.onicecandidate = ({ candidate }) => {
                    if (candidate) {
                        // Ch·ªâ g·ª≠i candidate khi WS ƒë√£ m·ªü
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            ws.send(JSON.stringify({
                                type: 'candidate',
                                candidate: candidate.toJSON(),
                                session_id: sessionID
                            }));
                        }
                    }
                };

                pc.oniceconnectionstatechange = () => {
                    log(`Tr·∫°ng th√°i ICE: ${pc.iceConnectionState}`, 'status');
                    if (pc.iceConnectionState === 'disconnected' || pc.iceConnectionState === 'failed') {
                        log('K·∫øt n·ªëi WebRTC b·ªã ƒë√≥ng b·∫•t ng·ªù.', 'error');
                    }
                };
                
                pc.onconnectionstatechange = () => {
                    log(`Tr·∫°ng th√°i k·∫øt n·ªëi: ${pc.connectionState}`, 'status');
                    if (pc.connectionState === 'failed' || pc.connectionState === 'closed') {
                         log('K·∫øt n·ªëi WebRTC th·∫•t b·∫°i/ƒë√≥ng.', 'error');
                         resetUI();
                    }
                };


                // === HANDLERS CHO DATA CHANNEL ===
                dataChannel = pc.createDataChannel("data-channel");
                
                dataChannel.onopen = () => {
                    updateStatus('Data Channel ƒë√£ m·ªü. B·∫Øt ƒë·∫ßu ghi √¢m...', 30);
                    startBtn.disabled = true;
                    stopBtn.disabled = false;
                };

                dataChannel.onclose = () => {
                    log('Data Channel ƒë√£ ƒë√≥ng.', 'status');
                };

                dataChannel.onmessage = handleDataChannelMessage;

                // Th√™m Media Track
                localStream.getTracks().forEach(track => {
                    pc.addTrack(track, localStream);
                });

                // T·∫°o Offer v√† g·ª≠i ƒë·∫øn Server
                pc.createOffer().then(offer => {
                    return pc.setLocalDescription(offer);
                }).then(() => {
                    const offer = pc.localDescription;
                    const api_key = apiKeyInput.value.trim();
                    
                    // G·ª≠i Offer qua HTTP POST
                    return fetch('/offer', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            sdp: offer.sdp,
                            type: offer.type,
                            session_id: sessionID,
                            api_key: api_key 
                        })
                    });
                }).then(response => response.json()).then(async answer => {
                    // Nh·∫≠n Answer t·ª´ Server
                    await pc.setRemoteDescription(new RTCSessionDescription(answer));
                    updateStatus('K·∫øt n·ªëi WebRTC ƒë√£ thi·∫øt l·∫≠p. ƒêang ch·ªù Data Channel m·ªü.', 50);
                }).catch(error => {
                    log(`L·ªói thi·∫øt l·∫≠p WebRTC: ${error}`, 'error');
                    resetUI();
                });

            } catch (error) {
                log(`L·ªói PeerConnection: ${error}`, 'error');
                resetUI();
            }
        }
        
        // ======================================================
        // L√îGIC X·ª¨ L√ù D·ªÆ LI·ªÜU
        // ======================================================

        function handleDataChannelMessage(event) {
            const data = event.data;
            try {
                const message = JSON.parse(data);
                
                if (message.type === 'start_processing') {
                    isProcessing = true;
                    log('Server: B·∫Øt ƒë·∫ßu x·ª≠ l√Ω ASR/DM.', 'status');
                    updateStatus('Server: ƒêang x·ª≠ l√Ω ASR/NLU...', 60);
                    cancelBtn.style.display = 'inline-block';
                    cancelBtn.disabled = false;
                } else if (message.type === 'text_response') {
                    log(`Server: Nh·∫≠n ph·∫£n h·ªìi vƒÉn b·∫£n. User: ${message.user_text} | Bot: ${message.bot_text}`, 'status');
                    asrResult.textContent = message.user_text || '[Kh√¥ng c√≥ gi·ªçng n√≥i]';
                    botResponse.textContent = message.bot_text || '[Kh√¥ng c√≥ ph·∫£n h·ªìi]';
                    updateStatus('Server: Nh·∫≠n ph·∫£n h·ªìi. B·∫Øt ƒë·∫ßu TTS...', 80);
                } else if (message.type === 'audio_chunk') {
                    const audioBase64 = message.chunk;
                    const audioBlob = base64ToBlob(audioBase64, 'audio/wav');
                    
                    ttsAudio.src = URL.createObjectURL(audioBlob);
                    ttsAudio.play();
                    
                    updateStatus('ƒêang ph√°t audio ph·∫£n h·ªìi...', 90);
                } else if (message.type === 'end_of_session') {
                    log('Server: K·∫øt th√∫c phi√™n x·ª≠ l√Ω.', 'status');
                    cancelBtn.style.display = 'none';
                    cancelBtn.disabled = true;
                    isProcessing = false;
                } else if (message.type === 'error') {
                    log(`Server L·ªñI: ${message.error}`, 'error');
                    resetUI();
                }

            } catch (e) {
                log(`L·ªói x·ª≠ l√Ω DataChannel: ${e.message}`, 'error');
            }
        }
        
        function base64ToBlob(base64, mimeType) {
            const byteCharacters = atob(base64);
            const byteArrays = [];
            for (let offset = 0; offset < byteCharacters.length; offset += 512) {
                const slice = byteCharacters.slice(offset, offset + 512);
                const byteNumbers = new Array(slice.length);
                for (let i = 0; i < slice.length; i++) {
                    byteNumbers[i] = slice.charCodeAt(i);
                }
                const byteArray = new Uint8Array(byteNumbers);
                byteArrays.push(byteArray);
            }
            return new Blob(byteArrays, { type: mimeType });
        }


        function stopRecording() {
            if (pc && pc.connectionState === 'connected') {
                log('üõë Y√™u c·∫ßu D·ª´ng Ghi √Çm v√† B·∫Øt ƒê·∫ßu X·ª≠ L√Ω...', 'status');
                stopBtn.disabled = true;
                
                // S·ª≠ d·ª•ng dataChannel ƒë√£ ƒë∆∞·ª£c kh·ªüi t·∫°o
                if (dataChannel && dataChannel.readyState === 'open') {
                    dataChannel.send(JSON.stringify({ type: 'stop_recording' }));
                } else {
                     log('Data Channel ch∆∞a s·∫µn s√†ng ƒë·ªÉ g·ª≠i l·ªánh d·ª´ng.', 'warn');
                }
                
                localStream.getTracks().forEach(track => track.stop());
                
                updateStatus('ƒê√£ d·ª´ng ghi √¢m. ƒêang ch·ªù server ph·∫£n h·ªìi...', 55);
            }
        }
        
        function sendCancelMessage() {
             if (dataChannel && dataChannel.readyState === 'open' && isProcessing) {
                 log('‚ùå G·ª≠i l·ªánh H·ª¶Y X·ª¨ L√ù ƒë·∫øn Server.', 'error');
                 dataChannel.send(JSON.stringify({ type: 'cancel_processing' }));
                 resetUI();
             }
        }
        
        // ======================================================
        // L√îGIC KH·ªûI T·∫†O MICRO
        // ======================================================
        
        async function init() {
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                try {
                    // Ch·ªâ kh·ªüi t·∫°o Local Stream
                    localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    log('Truy c·∫≠p Micro th√†nh c√¥ng. S·∫µn s√†ng k·∫øt n·ªëi.', 'status');
                    startBtn.disabled = false;
                    stopBtn.disabled = true;
                } catch (e) {
                    log(`L·ªói truy c·∫≠p Micro: ${e.message}`, 'error');
                    alert("Kh√¥ng th·ªÉ truy c·∫≠p Micro. Vui l√≤ng c·∫•p quy·ªÅn.");
                }
            } else {
                log('WebRTC kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£ tr√™n tr√¨nh duy·ªát n√†y.', 'error');
                alert("Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ WebRTC.");
            }
        }

        // ======================================================
        // EVENT LISTENERS
        // ======================================================
        startBtn.addEventListener('click', async () => {
             // ƒê·∫£m b·∫£o stream ƒë√£ c√≥
             if (!localStream) {
                 await init();
             }
             if (localStream) {
                 createPeerConnection(); // T·∫°o PC v√† g·ªçi initWebSocket b√™n trong
             }
        });
        
        stopBtn.addEventListener('click', stopRecording); 

        cancelBtn.addEventListener('click', sendCancelMessage);
        
        ttsAudio.onended = () => {
             log('[TTS] K·∫øt th√∫c ph√°t audio.', 'status');
             updateStatus('ƒê√£ x·ª≠ l√Ω xong. S·∫µn s√†ng cho phi√™n m·ªõi.', 100);
             resetUI(); 
        }

        window.onload = function() {
            // Kh√¥i ph·ª•c/L∆∞u API Key
            const savedKey = localStorage.getItem('voice_ai_api_key');
            if (savedKey) {
                apiKeyInput.value = savedKey;
            } 
            init(); // Ch·ªâ init Micro, KH√îNG init WebSocket
        };

        apiKeyInput.addEventListener('change', () => {
            const key = apiKeyInput.value.trim();
            localStorage.setItem('voice_ai_api_key', key);
            log("API Key ƒë√£ ƒë∆∞·ª£c l∆∞u t·∫°m th·ªùi.", 'status');
        });

    </script>
</body>
</html>